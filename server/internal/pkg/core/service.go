package core

import (
	"fmt"
	"reflect"

	"github.com/aritradevelops/authinfinity/server/internal/auth"
	"github.com/aritradevelops/authinfinity/server/internal/pkg/validator"
	"github.com/gofiber/fiber/v2"
)

type Service[S Schema] interface {
	List(*fiber.Ctx) (*PaginatedResponse[S], error)
	Create(*fiber.Ctx) (string, error)
	Update(*fiber.Ctx) (bool, error)
	View(*fiber.Ctx) (S, error)
	Delete(*fiber.Ctx) (bool, error)
}

type BaseService[S Schema] struct {
	repository Repository[S]
}

func NewService[S Schema](repository Repository[S]) Service[S] {
	return &BaseService[S]{
		repository: repository,
	}
}

func (s *BaseService[S]) List(c *fiber.Ctx) (*PaginatedResponse[S], error) {
	listOpts, err := NewListOptions(c)
	if err != nil {
		return nil, NewBadRequestError(c)
	}
	response, err := s.repository.List(listOpts)
	return response, err
}
func (s *BaseService[S]) Create(c *fiber.Ctx) (string, error) {
	var data S
	err := c.BodyParser(&data)
	if err != nil {
		fmt.Printf("Error : %+v", err)
		return "", NewBadRequestError(c)
	}
	authUser, err := auth.GetAuthUser(c)
	if err == nil {
		data.SetCreatedAt()
		data.SetCreatedBy(authUser.ID)
		data.SetAccountID(authUser.AccountID)
	}
	if generator, ok := any(data).(AutoGenerated); ok {
		if err := generator.Generate(); err != nil {
			return "", NewInternalServerError(c)
		}
	}
	errs := validator.Validate(data, c)
	if errs != nil {
		fmt.Printf("Error : %+v", err)
		return "", NewRequestValidationError(c, errs)
	}

	return s.repository.Create(data)
}

func (s *BaseService[S]) Update(c *fiber.Ctx) (bool, error) {
	id := c.Params("id")
	var data S
	err := c.BodyParser(&data)
	if err != nil {
		fmt.Printf("Error : %+v", err)
		return false, NewBadRequestError(c)
	}
	authUser, err := auth.GetAuthUser(c)
	if err == nil {
		data.SetUpdatedAt()
		data.SetUpdatedBy(authUser.ID)
	}
	errs := validator.Validate(data, c)
	if errs != nil {
		fmt.Printf("Error : %+v", err)
		return false, NewRequestValidationError(c, errs)
	}
	filter := make(Filter)
	filter["id"] = id
	filter["deleted_at"] = nil
	return s.repository.Update(filter, data)
}
func (s *BaseService[S]) View(c *fiber.Ctx) (S, error) {
	id := c.Params("id")
	filter := make(Filter)
	filter["id"] = id
	filter["deleted_at"] = nil
	var data S
	err := s.repository.View(filter, &data)

	if err != nil {
		return data, err
	}
	return data, nil
}
func (s *BaseService[S]) Delete(c *fiber.Ctx) (bool, error) {
	id := c.Params("id")
	schema := reflect.New(reflect.TypeFor[S]().Elem())
	data := schema.Interface().(S)
	authUser, err := auth.GetAuthUser(c)
	if err == nil {
		data.SetDeletedAt()
		data.SetDeletedBy(authUser.ID)
	}
	filter := make(Filter)
	filter["id"] = id
	filter["deleted_at"] = nil
	return s.repository.Update(filter, data)
}
